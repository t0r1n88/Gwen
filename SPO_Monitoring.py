import pandas as pd
import openpyxl
import os


def processing_column_other(text: str):
    """
    Функция для подсчета причин указанных в колонке Прочее
    :param text: Текст разделенный запятыми
    :return: Текст разделенный знаками переноса вида:
     семейные обстоятельства -3
     переезд -4
    """
    if text == 'Нет':
        return ''
    else:
        # Создаем словарь для подсчета
        word_frequency = dict()
        # Очищаем текст от возможных знаков переноса

        text = text.replace('', '')
        text = text.replace("\n", " ")
        # Создаем список
        word_lst = text.split(',')

        # Итерируемся по списку слов и подсчитываем количество
        for word in word_lst:
            # о костыль.Но странно почему replace не срабатывает
            if word == '':
                continue
            if word in word_frequency:
                # Создаем ключ с заглавной буквы, чтобы потом не тратить на это время
                word_frequency[word] += 1
            else:
                word_frequency[word] = 1
        # Превращаем словарь в список, чтобы метод join правильно отработал
        output_lst = []
        for reason in word_frequency.items():
            output_lst.append(f'{reason[0]} - {reason[1]}')
        return ',\n'.join(output_lst)


def check_data(df, quantity):
    """
    Функция для проверки полученного датафрейма на корректность данных.
    Проверка фактических и планируемых показателей, проверка количества целевиков и инвалидов.
    :param df: однострочный датафрейм полученный после суммирования
    :quantity: количество студентов
    :return: строка со статусом проверки
    """
    # Создаем счетчики для подсчета причин из колонок Прочее и План.Прочее
    real_count_reason = 0
    plan_count_reason = 0
    # Сохраняем данные из колонок Прочее и План.Прочее
    # Делаем срез, сплитим по , отбрасываем последний элемент поскольку это пустая строка
    real_text_reasons = df.loc[0, 'Прочее'].split(',')[:-1]
    plan_text_reasons = df.loc[0, 'План.Прочее'].split(',')[:-1]

    # считаем количество реальных причин
    for real_reason in real_text_reasons:
        # Условие, чтобы не учитывать пустую строку которая образуется
        if real_reason != 'Нет':
            real_count_reason += 1

    # считаем количество плановых  причин
    for plan_reason in plan_text_reasons:
        if plan_reason != 'Нет':
            plan_count_reason += 1

    # Теперь считаем сумму реальных и плановых столбцов + количество в столбцах Прочее. Кстати можно было изначально посчитать их с помощью count
    # print(df.info())
    # real_other_sum = df.iloc[0,3:12].sum()
    # print(real_other_sum)

    # plan_text_reasons = df['План.Прочее'].values
    # # считаем количество планируемых причин
    # for plan_reason in plan_text_reasons.split(','):
    #     if not plan_reason == '':
    #         plan_count_reason += 1

    # print(real_count_reason)
    # print(plan_count_reason)

    # Удаляем колонки с причинами
    df.drop(['Прочее', 'План.Прочее'], axis=1, inplace=True)
    # Получаем строку с итогами по фактическому распределению выпускников


def processing_type_df(df):
    """
    Функция для обработки датафрейма. Обработка nan, конвертирование типов колонок
    :param df: датафрейм
    :return: обработанный датафрейм
    """
    # Заменяем None в колонках для того чтобы избежать в последующем проблем с проверкой данных

    df.fillna(value={'Трудоустроен': 0, 'ИП': 0, 'Самозанятые': 0, 'Призваны в ВС': 0, 'Продолжают обучение': 0,
                     'Находятся в отпуске по уходу за ребенком': 0,
                     'Находящиеся под риском нетрудоустройства': 0, 'Состоят на учете в центрах занятости': 0,
                     'Не определились': 0, 'План.Трудоустроен': 0
        , 'План.ИП': 0, 'План.Самозанятые': 0, 'План.Призваны в ВС': 0, 'План.Продолжают обучение': 0,
                     'План.Находятся в отпуске по уходу за ребенком': 0,
                     'План.Находящиеся под риском нетрудоустройства': 0,
                     'План.Состоят на учете в центрах занятости': 0, 'План.Не определились': 0, 'Всего': 0,
                     'Лица с ограниченными возможностями здоровья': 0, 'Инвалиды и дети-инвалиды': 0,
                     'Инвалиды и дети-инвалиды (кроме учтенных в строке 03)': 0,
                     'Имеют договор о целевом обучении': 0,
                     'Лица с ограниченными возможностями здоровья (имеющие договор о целевом обучении)': 0,
                     'Инвалиды и дети-инвалиды (имеющие договор о целевом обучении)': 0,
                     'Инвалиды и дети-инвалиды (кроме учтенных в предыдущем столбце) (имеющие договор о целевом обучении)': 0},
              inplace=True)
    df.fillna(value={'Прочее': 'Нет,', 'План.Прочее': 'Нет,'}, inplace=True)
    # Применяем ко всему датафрейму конвертирование в инт, текстовые типы будут пропущены

    df[['Трудоустроен', 'ИП', 'Самозанятые', 'Призваны в ВС', 'Продолжают обучение',
        'Находятся в отпуске по уходу за ребенком',
        'Находящиеся под риском нетрудоустройства', 'Состоят на учете в центрах занятости', 'Не определились',
        'План.Трудоустроен'
        , 'План.ИП', 'План.Самозанятые', 'План.Призваны в ВС', 'План.Продолжают обучение',
        'План.Находятся в отпуске по уходу за ребенком', 'План.Находящиеся под риском нетрудоустройства',
        'План.Состоят на учете в центрах занятости', 'План.Не определились', 'Всего',
        'Лица с ограниченными возможностями здоровья', 'Инвалиды и дети-инвалиды',
        'Инвалиды и дети-инвалиды (кроме учтенных в строке 03)',
        'Имеют договор о целевом обучении',
        'Лица с ограниченными возможностями здоровья (имеющие договор о целевом обучении)',
        'Инвалиды и дети-инвалиды (имеющие договор о целевом обучении)',
        'Инвалиды и дети-инвалиды (кроме учтенных в предыдущем столбце) (имеющие договор о целевом обучении)']] \
        = df[['Трудоустроен', 'ИП', 'Самозанятые', 'Призваны в ВС', 'Продолжают обучение',
              'Находятся в отпуске по уходу за ребенком',
              'Находящиеся под риском нетрудоустройства', 'Состоят на учете в центрах занятости', 'Не определились',
              'План.Трудоустроен'
        , 'План.ИП', 'План.Самозанятые', 'План.Призваны в ВС', 'План.Продолжают обучение',
              'План.Находятся в отпуске по уходу за ребенком', 'План.Находящиеся под риском нетрудоустройства',
              'План.Состоят на учете в центрах занятости', 'План.Не определились', 'Всего',
              'Лица с ограниченными возможностями здоровья', 'Инвалиды и дети-инвалиды',
              'Инвалиды и дети-инвалиды (кроме учтенных в строке 03)',
              'Имеют договор о целевом обучении',
              'Лица с ограниченными возможностями здоровья (имеющие договор о целевом обучении)',
              'Инвалиды и дети-инвалиды (имеющие договор о целевом обучении)',
              'Инвалиды и дети-инвалиды (кроме учтенных в предыдущем столбце) (имеющие договор о целевом обучении)']].astype(
        'int64')
    # Устанавливаем для колонки Статус тип поля текстовый
    df['Статус'] = df['Статус'].astype('str')
    return df


def check_quantity_row(df):
    """
    Функция для проверки количества строк в сгруппированном датафрейме. На случай если в списке группы окажутся другие
    специальности или кураторы, ну или просто преподаватель опечатается
    :param df: сгруппированный датафрейм
    :return: статус проверки
    """
    # В корректном файле должно быть 1 строка и 32 колонки
    if df.shape[0] != 1 or df.shape[1] != 32:
        return None
    else:
        return True


def check_columns_name(base_df, checked_df):
    """
    Функция для проверки корректности названий колонок
    :param base_df: эталонный датафрейм с колонками
    :param checked_df: проверяемый датафрейм
    :return: результат проверки
    """

    if (len(base_df.columns) == len(checked_df.columns)) and (all((base_df.columns == checked_df.columns))):
        return True
    else:
        return None


# Создаем базовый  датафрейм
base_df = pd.read_excel('temp/columns.xlsx')

# Получаем список файлов
example_dir = 'C:/Users/1/PycharmProjects/Gwen/resources'
with os.scandir(example_dir) as files:
    lst_files = [file.name for file in files if file.is_file() and file.name.endswith('xlsx')]
# Перебираем файлы
for file in lst_files:

    df = pd.read_excel(f'resources/{file}')
    # Проверяем корректность названий колонок
    if not check_columns_name(base_df, df):
        print('Некорректное количество колонок или название колонок')
        continue

    # Удаляем столбец с ФИО, так как при группировке он будет мешать
    df = df.drop(['ФИО'], axis=1)

    df = processing_type_df(df)

    # добавляем параметр numeric_only чтобы текстовые значения также суммировались
    temp_df = df.groupby(['Специальность', 'Группа', 'Куратор'], ).sum(numeric_only=False).reset_index()
    # TODO проверка количества строк. Должно быть не более 1, если больше то в файле присутствует еще одна группа,куратор,специальность
    if not check_quantity_row(temp_df):
        print('В файле присутствуют другие специальности,группы,кураторы или есть ошибки в написании')
        continue

    # Копируем датафрейм, так как внутри функции он будет изменятся
    checked_df = temp_df.copy()
    # Получаем результат проверки
    verification_status = check_data(temp_df, df.shape[0])
    # Добавляем данные в итоговый датафрейм
    # checked_df['Статус'] = verification_status

    base_df = base_df.append(checked_df, ignore_index=True)

# Сохраняем промежуточный  результат для того чтобы легче было отслеживать корректность данных
base_df.to_excel('Промежуточный результат.xlsx', index=False)

# Проводим итоговую группировку
# Нужно провести подсчет причин в графе Прочие.
itog_df = base_df.groupby(['Специальность']).sum(numeric_only=False).reset_index()

# Обрабатываем колонку Прочее
# Сначала приводим заменяем возможные 0.0 на строку Отсутствуют
# itog_df['Прочее'] = itog_df['Прочее'].apply(lambda x: 'Отсутствуют' if not type(x) == str else x)
itog_df['Прочее'] = itog_df['Прочее'].apply(processing_column_other)
itog_df['План.Прочее'] = itog_df['План.Прочее'].apply(processing_column_other)

itog_df.to_excel('Итоговый результат.xlsx', index=False)
